# Service Mesh

Mostly used in container platforms, sidecar approach is most widely adopted.
Sidecar proxy handles incoming and outgoing traffic. Proxies are controlled
by a generic control plane. Config is managed through CRDs.

A service mesh uses L7 routing. This is a high level, so we can use a different configuration
between GET and POST requests. A service mesh can route in request level, so instead of load
balancing a connection, we can load balance requests. Header-based routing is supported,
usefully when routing mobile devices to other pods than computers. If you can't handle the load,
you can give higher priority to a certain group of users. Built-in retries can retry the
request toe same or different origin pod.

Traffic shifting divides the requests over multiple pods in the form of canary deployment,
A/B testing or blue/green deployments. Can integrate with https://argoproj.github.io/argo-rollouts/

Traffic mirroring sends 100% of the traffic to a new version, but don't send the response back,
it's more fire and forget.

All requests on the sidecar proxy can be logged with all information. All logs are printed to 
stdout, so can be handled by fluentd or whatever. Pretty automated access logging.
https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage

Tracing between applications can be managed by a service mesh, which sets trace headers when the
request hits the first sidecar proxy and the trace header is not set yet. In the application,
you need to pass the tracing headers from the request to the response. **How does this work with 3rd party applications?**
Use https://opentelemetry.io/ in the application. Jaeger can visualize tracing information, but not sure
yet how this integrates with a Service Mesh. https://www.consul.io/docs/connect/distributed-tracing

Metrics can be generated by the service mesh, for example the amount of requests, duration and success rate.
This is nice for detecting DDOS attacks as well, or a little nicer,spikes in traffic.

All metrics are the same between applications connected to the service mesh. This means
you can reuse Grafana dashboards for all applications.

Authentication works through mutual TLS. All traffic between components can be encrypted through mTLS.
Service Meshen can also authenticate with JWT tokens. I think you set an authority and the service mesh
injects it into requests. The service mesh can also be validated. **Can we fully strip authentication
and authorization from applications?** 

Authorization happens through policies, this can be workload-to-workload and user-to-workload. Policies
are fine-grained enough, you can include request methods and paths. Most firewalls are on layer 3 or 4
and lack fine-grained control over the requests.

- https://cilium.io/, can work on kernel level, installed on node level, works proxy-less. **Does this work on AKS/EKS?**
  - Is this a service mesh or a CNI?
- https://openservicemesh.io/
- Consul
- Linderd, lacks some features, but is focused on speed and security
- Istio, lots of features, but is heavy as hell. Uses envoy proxy as sidecar, which introduces latency.

